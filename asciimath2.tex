% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
% 
% OLD VERSION:
% OK, let's try without having spaces be tokens:
% Only issue is braces...
% Given a list of previously stored blocks:
% Peek 

% Separate into two parts:
% First, set spaces to active so they can be easily eaten
% Then, parse the characters inside of the `...` .  
% Now, all spaces read are active.

\newlinechar=`@

% OK, change: need  to fully lex into a token register before outputting.
\newtoks\tempStrA
\def\appendToks#1#2{
    \tempStrA={#2}%
%    \message{Appending to \noexpand#1: [\the#1] plus [\the\tempStrA]@}
    \edef\tmpA{\the#1\the\tempStrA}%
    #1=\expandafter{\tmpA}%
}

\catcode96=13%
\def`{\setup\startParse}
\def\setup{
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
    %\defParenCmds
}

\newtoks\lexedTokens
\def\addLexed{\appendToks\lexedTokens}
\def\addBlock#1{\appendToks\lexedTokens{\block0{#1}}}

\def\startParse#1`{%
    \message{Starting to lex:}
    \lexedTokens={}\lexTokens#1\end
    \message{The lexed tokens:}
    \showthe\lexedTokens
    \message{done.}
    \mathdelim\the\lexedTokens\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
%
\begingroup
\catcode32=13
%\catcode40=13
\gdef\sspaceB{ }
\gdef\sparenB{(}
\catcode32=10
\endgroup



% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\gdef\lexTokens#1{%
    \ifx#1\end\let\next=\relax
    \else
    %\message{About to test spaces...first is:}
    %\show#1%
    %\message{And second is:}
    %\show\sspaceB
    %\message{So there.}
    %\if\sspaceB\noexpand#1\message{YESYES}\else\message{NONO}\fi
    % the noexpand is necessary if eg we parse an active (.
    \if\sspaceB\noexpand#1\let\next=\lexTokens% ignore spaces
    \else\ifx#1/\def\next{\addLexed{\binOp\frac}\lexTokens}%
    \else\ifx#1(\def\next{\addLexed{\startParen}\lexTokens}%
    \else\ifx#1)\def\next{\addLexed{\endParen}\lexTokens}%
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS#1}%
    \else\def\next{\addBlock#1\lexTokens}%
    \fi\fi\fi\fi\fi\fi
    \next
}%

\newtoks\csNameStr
\def\parseLetterOrCS#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\nextTok a\def\next{\csNameStr={#1}\parseCS}%
                \else\def\next{\addBlock#1\lexTokens}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS{\futurelet\nextTok\parseCSa}
\def\parseCSa{%
    \ifcat\nextTok a\def\next{\addToCSAndCont}%
    \else\def\next{\emitCSAndLex}%
    \fi\next
}
\def\addToCSAndCont#1{%
    \appendToks\csNameStr#1%\edef\next{\noexpand\csNameStr={\the\csNameStr#1}}%
    \parseCS
}
\def\emitCSAndLex{%
    \edef\nextL{\the\csNameStr}
    \expandafter\expandafter\expandafter\addBlock\expandafter\csname\nextL\endcsname\lexTokens
    %\edef\nextL{\csname\the\csNameStr\endcsname}%
    %\expandafter\addLexed\nextL\lexTokens
}

%%%%%%%%%%%%%%
%% Building from blocks
% 
% OK, the lexer's done.  First up: startParen, which just expands
% into a \block1.

\newtoks\parenContents
\newcount\parenLevel
\def\startParen{\parenLevel=0\parenContents={}\scanParenBlock}
\def\scanParenBlock#1{%
    %\message{We're at:\noexpand#1}
    \ifx#1\endParen
        \ifnum\parenLevel>0%
            \advance\parenLevel by -1%
            \def\next{\appendToks\parenContents{#1}\scanParenBlock}%
        \else\let\next=\blockedParenContents
        \fi
    \else
        \ifx#1\startParen\advance\parenLevel by 1%
        \fi
        \appendToks\parenContents{#1}%
        \let\next=\scanParenBlock
    \fi
    \next
}
\def\blockedParenContents{%
    \expandafter\block\expandafter1\expandafter{\the\parenContents}%
}

% TODO: for now, don't worry about parens in denominator.

% Next, block checks whether it's followed by a binOp.  If not, just output.
% Otherwise, pass into the binOp.
\def\block#1#2{%
    \tempStrA={#1,#2}
    \message{Outputting block [#1]: \the\tempStrA@}
    %\ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
    \def\todo{\blockA#1{#2}}\futurelet\nextTok\todo
}
\def\blockA#1#2{%
    \ifx\nextTok\binOp\def\next{\runBinOp{#2}}%
    \else\def\next{\outputPlain#1{#2}}%
    \fi
    \next
}
\def\outputPlain#1#2{%
    \ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
}
\newtoks\tempStrB
\newtoks\tempStrC

\def\runBinOp#1\binOp#2#3{
    \ifx#3\block\def\next##1##2{\block0{#2{#1}{##2}}}
    %\else\ifx#3\startParen
    \else\def\next{\message{Sorry, I can't handle this type:\noexpand#3}\end}%
    \fi%\fi
    \next
}
%% hack for now; assume denom is simple block:
%\def\runBinOp#1\binOp#2\block0#3{%
%    \tempStrB={#1,#2,#3}
%    \message{RunBinOp:\the\tempStrB@}
%    #2{#1}{#3}%
%}

% For testing:
\def\binOp#1{#1}


%%%%%%%%%%%%%%%%%%%%
% Examples
\def\startTrace{\message{Starting trace...@}%
    \tracingmacros=2\tracingassigns=2\tracingcommands=2%
}
\def\endTrace{\message{Ending trace...}\tracingmacros=0\tracingassigns=0\tracingcommands=0}


% TODO: frac is being expanded too early...
\def\frac#1#2{%
    {#1\over#2}%
}
\startTrace
%` startTrace (alpha(frac2)) endTrace`

$$` 2/3 + ((alpha+2)/2 * 5)/7`$$

`2/3/3`
\endTrace

\bye
