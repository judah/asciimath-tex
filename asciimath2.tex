% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
 

\newlinechar=`@

% OK, change: need  to fully lex into a token register before outputting.
\newtoks\tempStrA
\def\appendToks#1#2{%
    \tempStrA={#2}%
%    \message{Appending to \noexpand#1: [\the#1] plus [\the\tempStrA]@}
    \edef\tmpA{\the#1\the\tempStrA}%
    #1=\expandafter{\tmpA}%
}

\catcode96=13%
\def`{\setup\startParse}
\def\setup{%
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
    %\defParenCmds
}

\newtoks\lexedTokens
\def\addLexed{\appendToks\lexedTokens}
\def\addBlock#1{\appendToks\lexedTokens{\block0{#1}}}

\def\startParse#1`{%
    %\message{Starting to lex:}
    \lexedTokens={}\lexTokens#1\end
    %\message{The lexed tokens:}%
    %\showthe\lexedTokens
    %\message{done.}%
    \mathdelim\the\lexedTokens\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
% 
% TODO (maybe these shouldn't go here):
% * Register \sqrt (maybe that shouldn't go here?)
% * Try using operator precedence: a^2/b_3 == (a^2)/(b_3)
% * also a^2_1 should work better
%
\begingroup
\catcode32=13
%\catcode40=13
\gdef\sspaceB{ }
\gdef\sparenB{(}
\catcode32=10
\endgroup



% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\gdef\lexTokens#1{%
    \ifx#1\end\let\next=\relax
    %\message{About to test spaces...first is:}
    %\show#1%
    %\message{And second is:}
    %\show\sspaceB
    %\message{So there.}
    %\if\sspaceB\noexpand#1\message{YESYES}\else\message{NONO}\fi
    % the noexpand is necessary if eg we parse an active (.
    \else\if\sspaceB\noexpand#1\let\next=\lexTokens% ignore spaces
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS#1}%
    \else\ifcat\noexpand#1^\def\next{\addLexed{\binOp\Superscript}\lexTokens}%
    \else\ifcat\noexpand#1_\def\next{\addLexed{\binOp\Subscript}\lexTokens}%
    \else\ifcat\noexpand#1/\def\next{\processOtherChar#1}%
    \else\def\next{\addBlock{#1}\lexTokens}%
    \fi\fi\fi\fi\fi\fi
    \next
}%

\def\processOtherChar#1{%
    \ifx#1/\let\next=\scanFracOrDiv
    \else\ifx#1(\def\next{\addLexed{\startParen}\lexTokens}%
    \else\ifx#1)\def\next{\addLexed{\endParen}\lexTokens}%
    \else\ifx#1-\def\next{\scanMinusOrNeg}%
    % TODO: if it's a digit (or if it's a '-' and the next token's a digit
    % then read a number and turn it into a block.
    \else
        \ifisdigit#1{\def\next{\scanNumber{#1}}}%
            {\def\next{\addBlock{#1}\lexTokens}}%
    \fi\fi\fi\fi
    \next
}

\def\scanFracOrDiv{\futurelet\nextTok\scanFracOrDivA}
\def\scanFracOrDivA{%
    \ifx\nextTok/\def\next##1{\addBlock{/}\lexTokens}%
    \else\def\next{\addLexed{\binOp\fracOp}\lexTokens}%
    \fi
    \next
}

% There must be a more efficient way to do this...
\newif\ifisDigitCond
\def\ifisdigit#1#2#3{%
    \isDigitCondfalse
    \ifx0#1\isDigitCondtrue\fi
    \ifx1#1\isDigitCondtrue\fi
    \ifx2#1\isDigitCondtrue\fi
    \ifx3#1\isDigitCondtrue\fi
    \ifx4#1\isDigitCondtrue\fi
    \ifx5#1\isDigitCondtrue\fi
    \ifx6#1\isDigitCondtrue\fi
    \ifx7#1\isDigitCondtrue\fi
    \ifx8#1\isDigitCondtrue\fi
    \ifx9#1\isDigitCondtrue\fi
    \ifisDigitCond#2\else#3\fi
}

\def\scanNumber#1{\def\todo{\scanNumberA{#1}}\futurelet\nextTok\todo}
\def\scanNumberA#1{%
    \ifisdigit\nextTok{\def\next##1{\scanNumber{#1##1}}}%
        {\def\next{\addBlock{#1}\lexTokens}}%
    \next
}

% scanned a '-'; need to peek one more to check if this starts a negative number.
\def\scanMinusOrNeg{\futurelet\nextTok\scanMinusOrNegA}
\def\scanMinusOrNegA{%
    \ifisdigit\nextTok
        {\def\next{\scanNumber{-}}}%
        {\def\next{\addBlock{-}\lexTokens}}%
    \next
}

%%%%%%%%%%%
% binary operations
\def\fracOp#1#2{%
    {#1\over#2}%
}
\def\Superscript#1#2{%
    {#1}^{#2}%
}
\def\Subscript#1#2{%
    {#1}_{#2}%
}

\newtoks\csNameStr
\def\parseLetterOrCS#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\nextTok a\def\next{\csNameStr={#1}\parseCS}%
                \else\def\next{\addBlock#1\lexTokens}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS{\futurelet\nextTok\parseCSa}
\def\parseCSa{%
    \ifcat\nextTok a\def\next{\addToCSAndCont}%
    \else\def\next{\emitCSAndLex}%
    \fi\next
}
\def\addToCSAndCont#1{%
    \appendToks\csNameStr#1%\edef\next{\noexpand\csNameStr={\the\csNameStr#1}}%
    \parseCS
}
\def\emitCSAndLex{%
    \edef\nextL{\the\csNameStr}
    \expandafter\expandafter\expandafter\addBlock\expandafter\csname\nextL\endcsname\lexTokens
    %\edef\nextL{\csname\the\csNameStr\endcsname}%
    %\expandafter\addLexed\nextL\lexTokens
}

%%%%%%%%%%%%%%
%% Building from blocks
% 
% OK, the lexer's done.  First up: startParen, which just expands
% into a \block1.

\newtoks\parenContents
\newcount\parenLevel


\def\startParen{\scanParenWrap\blockedParenContents}
\def\scanParenWrap#1{%
    \parenLevel=0\parenContents={}\scanParenBlock#1%
}
\def\scanParenBlock#1{\def\todo{\scanParenBlockA{#1}}\futurelet\nextTok\todo}
% Need to check for '{' b/c it's output by numbers...
\def\scanParenBlockA#1{%
    %\message{Checking if upcoming brace...@}
    %\show\bgroup
    %\show\nextTok
    \ifx\bgroup\nextTok
        \def\next{\scanBracedAndCont{#1}}%
    \else\def\next{\scanParenBlockB{#1}}%
    \fi\next
}
\def\scanBracedAndCont#1#2{%
    \appendToks\parenContents{{#2}}%
    \scanParenBlock#1%
}
% next is a single token, read it.
\def\scanParenBlockB#1#2{%
    \ifx#2\endParen
        \ifnum\parenLevel>0%
            \advance\parenLevel by -1%
            \def\next{\appendToks\parenContents{#2}\scanParenBlock#1}%
        \else\let\next=#1%
        \fi
    \else
        \ifx#2\startParen\advance\parenLevel by 1%
        \fi
        \appendToks\parenContents{#2}%
        \def\next{\scanParenBlock#1}%
    \fi
    \next
}
\def\blockedParenContents{%
    \expandafter\block\expandafter1\expandafter{\the\parenContents}%
}

% TODO: for now, don't worry about parens in denominator.

% Next, block checks whether it's followed by a binOp.  If not, just output.
% Otherwise, pass into the binOp.
\def\block#1#2{%
    \tempStrA={#1,#2}%
    %\message{Outputting block [#1]: \the\tempStrA@}
    %\ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
    \def\todo{\blockA#1{#2}}\futurelet\nextTok\todo
}
\def\blockA#1#2{%
    \ifx\nextTok\binOp\def\next{\runBinOp{#2}}%
    \else\def\next{\outputPlain#1{#2}}%
    \fi
    \next
}
\def\outputPlain#1#2{%
    \ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
}
\newtoks\tempStrB
\newtoks\tempStrC

\def\runBinOp#1\binOp#2#3{%
    \ifx#3\block\def\next##1##2{\block0{#2{#1}{##2}}}%
    \else\ifx#3\startParen\def\next{%
                    \def\useParen{\parenDenom{#1}{#2}}%
                    \scanParenWrap\useParen
                }%
    \else\def\next{\message{Sorry, I can't handle this type:\noexpand#3}\end}%
    \fi\fi
    \next
}

\newtoks\tmpToksD
\def\parenDenom#1#2{%
    %\message{In parenDenom: just parsed: \the\parenContents}%
    \tmpToksD={#1}
    \edef\todoC{\noexpand\block0{\noexpand#2{\the\tmpToksD}{\the\parenContents}}}%
    \todoC
}

%% hack for now; assume denom is simple block:
%\def\runBinOp#1\binOp#2\block0#3{%
%    \tempStrB={#1,#2,#3}
%    \message{RunBinOp:\the\tempStrB@}
%    #2{#1}{#3}%
%}

% For testing:
\def\binOp#1{\message{binOp: Something went wrong...\noexpand#1@}}


%%%%%%%%%%%%%%%%%%%%
% Examples
\def\startTrace{\message{Starting trace...@}%
    \tracingmacros=2\tracingassigns=2\tracingcommands=0%
}
\def\endTrace{\message{Ending trace...}\tracingmacros=0\tracingassigns=0\tracingcommands=0}

\parskip=10pt
\def\testit#1{%
    \par
    {\tt\char18\replaceSuperSubScript#1\end\char18}
    becomes: `#1`
    \par\par
}

% Hard to just set the catcodes because we want the ^ as letters in the \tt, and
% as superscripts in the `...`. 
\def\replaceSuperSubScript#1{%
    \ifx#1\end\let\next=\relax
    \else\ifx#1^\def\next{\char94\replaceSuperSubScript}%
    \else\ifx#1_\def\next{\char95\replaceSuperSubScript}%
    \else\def\next{#1\replaceSuperSubScript}%
    \fi\fi\fi
    \next
}

% TODO: frac is being expanded too early...
%` startTrace (alpha(frac2)) endTrace`
\testit{(9)}
\testit{(9^-74)}

\testit{3^2}
% TODO: test for space elimination.
\testit{ 125^-74}
% TODO: This should parse as 1/(125^74)
\testit{1/125^74}
\testit{(1/125)^74}
\testit{1-a}

\testit{(1//2)/(7//4)}
\testit{(9)/(7)}

\testit{ 2/3 + ((alpha+2)/2 * 5)/7}

\testit{2/3/3}

\testit{z/((q*(2/beta to gamma)))}

\testit{alpha^(2+3)/5}

\testit{a^1_2}

\bye
