\NeedsTeXFormat{LaTeX2e}[1994/12/01]
\ProvidesPackage{asciimth}[2009/12/11 v0.1 ASCIIMath support for LaTeX]
\RequirePackage{amsfonts}% for \mathbb


\def\appendToks@#1#2{%
    \edef\tmpA{\the#1}%
    #1=\expandafter{\tmpA#2}%
}

\catcode96=13%
\def`{%
    \setupASCII@
    \ifNextTokIs@`%
        {\endgroup\char96\char96}%
        {\startParse@}%
}
\def\setupASCII@{%
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    \defineTokTypes@
}

\newtoks\lexedTokens@
\def\addLexed@{\appendToks@\lexedTokens@}
\def\addBlock@#1{\addLexed@{\block0{}{#1}}}

% TODO: what's the right thing to do here?
% LaTeX redefines \end so I can't use it here...but startParse seems like a poor
% choice.
\def\startParse@#1`{%
    \lexedTokens@={}\lexTokens@#1\startParse@
    %\message{Lexed: \the\lexedTokens@.}%
    \mathdelim\the\lexedTokens@\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
% 
% TODO (maybe these shouldn't go here):
% * Register \sqrt (maybe that shouldn't go here?)
% * Try using operator precedence: a^2/b_3 == (a^2)/(b_3)
% * also a^2_1 should work better
%
\begingroup
\catcode32=13
%\catcode40=13
\gdef\sspace@{ }
\endgroup

% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\def\lexTokens@#1{%
    % ???? TODO ????
    \ifx#1\startParse@\let\next=\relax
    \else\if\sspace@\noexpand#1\let\next=\lexTokens@% ignore spaces
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS@#1}%
    \else\ifcat\noexpand#1^\def\next{\addLexed@{^}\lexTokens@}%
    \else\ifcat\noexpand#1_\def\next{\addLexed@{_}\lexTokens@}%
    \else\ifcat\noexpand#1/\def\next{\processOtherChar@#1}%
    \else\def\next{\addBlock@{#1}\lexTokens@}%
    \fi\fi\fi\fi\fi\fi
    \next
}%

\def\processOtherChar@#1{%
    \ifx#1/\let\next=\scanFracOrDiv@
    \else\ifx#1(\def\next{\addLexed@{\startParen(}\lexTokens@}%
    \else\ifx#1[\def\next{\addLexed@{\startParen[}\lexTokens@}%
    \else\ifx#1)\def\next{\addLexed@{\endParen)}\lexTokens@}%
    \else\ifx#1]\def\next{\addLexed@{\endParen]}\lexTokens@}%
    \else\ifx#1-\def\next{\addLexed@{-}\lexTokens@}%
    \else
        \ifisdigitchar@#1{\def\next{\scanNumber@{#1}}}%
            {\def\next{\addBlock@{#1}\lexTokens@}}%
    \fi\fi\fi\fi\fi\fi
    \next
}

\def\scanFracOrDiv@{\futurelet\nextTok\scanFracOrDivA@}
\def\scanFracOrDivA@{%
    \ifx\nextTok/\def\next##1{\addBlock@{/}\lexTokens@}%
    \else\def\next{\addLexed@{/}\lexTokens@}%
    \fi
    \next
}

% There must be a more efficient way to do this...
\newif\ifisDigitCharCond@
\def\ifisdigitchar@#1#2#3{%
    \isDigitCharCond@false
    \ifx0#1\isDigitCharCond@true\fi
    \ifx1#1\isDigitCharCond@true\fi
    \ifx2#1\isDigitCharCond@true\fi
    \ifx3#1\isDigitCharCond@true\fi
    \ifx4#1\isDigitCharCond@true\fi
    \ifx5#1\isDigitCharCond@true\fi
    \ifx6#1\isDigitCharCond@true\fi
    \ifx7#1\isDigitCharCond@true\fi
    \ifx8#1\isDigitCharCond@true\fi
    \ifx9#1\isDigitCharCond@true\fi
    \ifisDigitCharCond@#2\else#3\fi
}

\def\scanNumber@#1{\def\todo{\scanNumberA@{#1}}\futurelet\nextTok\todo}
\def\scanNumberA@#1{%
    \ifisdigitchar@\nextTok{\def\next##1{\scanNumber@{#1##1}}}%
        {\def\next{\addBlock@{#1}\lexTokens@}}%
    \next
}

\newtoks\csNameStr@
\def\parseLetterOrCS@#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\noexpand\nextTok a\def\next{\csNameStr@={#1}\parseCS@}%
                \else\def\next{\addBlock@#1\lexTokens@}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS@{\futurelet\nextTok\parseCSa@}
\def\parseCSa@{%
    \ifcat\noexpand\nextTok a\let\next=\addToCSAndCont@%
    \else\let\next=\emitCSAndLex@%
    \fi\next
}
\def\addToCSAndCont@#1{%
    \appendToks@\csNameStr@#1%
    \parseCS@
}

\def\emitCSAndLex@{\emitCSNameStr@\lexTokens@}
\def\emitCSNameStr@{%
    \edef\asciiCmdName{@\the\csNameStr@ @asciimacro@}%
    % First, check whether this name has been set with \addASCIIMathCmd:
    \expandafter\ifcsname\asciiCmdName\endcsname
        \def\next{\expandafter\addPredefinedName@\expandafter{\asciiCmdName}}%
    % Otherwise, check if it's set as a normal macro:
    \else\expandafter\ifcsname\the\csNameStr@\endcsname
        \def\next{%
            \expandafter\expandafter\expandafter
                \addBlock@\expandafter\csname\the\csNameStr@\endcsname
        }%
    \else\def\next{%
            \message{Oops, command "\the\csNameStr@" is not defined!}\end
        }%
    \fi\fi\next
}

\def\addPredefinedName@#1{%
    \expandafter\expandafter\expandafter\addPredefinedNameA@\csname#1\endcsname
}
\def\addPredefinedNameA@#1#2{%
    \addLexed@{\asciiCmd{#1}{#2}}%
}

%%%%%%%%%%%%%%
%% Parsing lexed tokens into a large structure
%
% Grammar is:
% 
% E ->  O E  | <empty>
% O ->  S    | S / S
% S ->  T    | T^Tm  | T_T   | T_T^Tm
% Tm -> T | -T
% T -> <block> or (E) | <func> T_1 ... T_n
% Each <func> was defined by addASCIIMathCmd
% and expects a fixed number of arguments.
%
% We handle the recursion by just accumulating the unexpanded inside
% and later outputting it inside of parens, \frac, etc.
% In particular, readO is NOT a recursive macro.
%
% Objects inside are:
% Raw operations /,^,_,-
% \block#1#2#3: #1 is 1 if this should be wrapped with parens when not a
%                   subexpr of a fraction, exponent, etc., and 0 otherwise.
%               #2 is eg "()" or "[)" if this should be wrapped
%               #3 is the internals of the block.
% \startParen#1: #1 is '(', '[', etc.
% \endParen#1: #1 is ')', ']', etc.
% \asciiCmd#1#2: #1 is code, #2 is number of args.
% 
% We also provide for other macros like \blockSqrt.  When it appears, it
% parses the upcoming block and expands into another block.

% When we get to an unprocessed block, we should start the parsing process over
% again.
\def\defineTokTypes@{%
    \def\block{\readO@\block}%
    \def\startParen{\readO@\startParen}%
    \def\endParen##1{\message{Oops; found an unmatched "##1".}\end}%
    \def\asciiCmd{\readO@\asciiCmd}%
}


\def\readO@{\let\useS=\maybeDoFraction@\readS@}
\def\maybeDoFraction@#1#2#3{%
    \ifNextTokIs@/{\readFraction@{#3}}{\putBlock@#1{#2}{#3}}%
}

% Checks whether the next token is #1.  If so, eats it and runs #2.
% Otherwise, leaves it alone and runs #3.
\def\ifNextTokIs@#1#2#3{%
    \def\todo{\ifx#1\nextTok\def\next####1{#2}\else\def\next{#3}\fi\next}%
    \futurelet\nextTok\todo
}
        
% Given the numerator to a fraction (#1)
% parses the next S and returns the resulting fraction.
\def\readFraction@#1{%
    \def\useS##1##2##3{\frac{#1}{##3}}%
    \readS@
}

% Reads an S nonterminal and passes the result to useS.
\def\readS@{%
    \def\useT##1##2##3{%
        \ifNextTokIs@_%
            {\doSubscript@{\putBlock@##1{##2}{##3}}}%
            {\ifNextTokIs@^%
                {\doSupscript@{\putBlock@##1{##2}{##3}}}%
                {\useS##1{##2}{##3}}}%
    }%
    \readT@
}
\def\doSubscript@#1{%
    \def\useT##1##2##3{%
        \ifNextTokIs@^%
            {\doSupscript@{#1_{##3}}}%
            {\useS0{}{#1_{##3}}}%
    }\readT@
}
% First, read an optional minus sign.
\def\doSupscript@#1{%
    \ifNextTokIs@-%
        {\doSupscriptA@1{#1}}%
        {\doSupscriptA@0{#1}}%
}
\def\doSupscriptA@#1#2{%
    \ifx1#1% minus sign
        \def\useT##1##2##3{%
            \useS0{}{#2^{-\putBlock@##1{##2}{##3}}}%
        }%
    \else
        \def\useT##1##2##3{%
            \useS0{}{#2^{##3}}%
        }%
    \fi
    \readT@
}


\def\putBlock@#1#2#3{%
    \ifx0#1\def\next{#3}%
    \else\def\next{\wrapBlock@#2{#3}}%
    \fi\next
}
% #1 is the open-delim, #2 is the close-delim.
% Note: using \left..\right makes the object in parentheses act like
% \mathinner, which isn't great since this happens to EVERY parenthesis.
% For example, in $f\left(x\right)$ there's too much space between
% the "f" and the "(". 
% Fix this by making it act like a \mathopen+\mathclose.
% Note we do still lose a tiny bit of kern between $f(x)$ and `f(x)`, but
% it's less noticeable.
% TODO: we could try checking the height of the inner formula ourselves, and
% use plain "(" and ")" if it's no bigger than those characters.
\def\wrapBlock@#1#2#3{\mathopen{}\mathclose{\left#1#3\right#2}}

% Reads a "T" terminal (a lone block or a parenthesized expression)
% and then passes it as an argument to \useT.
\def\readT@#1{%
    \ifx#1\block\let\next=\readTBlock@
    \else\ifx#1\startParen\let\next=\readTParen@
    \else\ifx#1\asciiCmd\let\next=\readTASCIICmd@
    \else\def\next{\message{Oops: ran into a non-block:\noexpand#1}\end}%
    \fi\fi\fi
    \next
}

% OK, this uses a couple of tricks:
% 1) The #1 of asciiCmdLoop@ is a partial application of the macro.
%    So appending something to that parameter means applying the macro
%    to an additional argument.
%
% 2) This function recursively calls readT.  So it saves the relevant
%    parameters by putting the readT call in a new group.
\newcount\cmdArgsNeeded@
\def\readTASCIICmd@#1#2{\cmdArgsNeeded@=#2\relax\asciiCmdLoop@{#1}}
\def\asciiCmdLoop@#1{%
    \ifnum\cmdArgsNeeded@=0%
        \def\next{\useT0{}{#1}}%
    \else
        \def\next{%
            \advance\cmdArgsNeeded@ by -1\relax%
            % start a new group since we need to keep around the old
            % version of useT and cmdArgsNeeded.
            \bgroup
            \def\useT####1####2####3{%
                \egroup
                \asciiCmdLoop@{#1{####3}}%
            }%
            \readT@
        }%
    \fi\next
}



\newtoks\parenContents@
\newcount\parenLevel@

\def\readTBlock@#1#2#3{\useT#1{#2}{#3}}
\def\readTParen@#1{%
    \def\parenStarter{#1}%
    \parenLevel@=0\parenContents@={}%
    \scanParenBlock@
}
% Need to check whether a '{' is next (e.g. lexing numbers produces it)
\def\scanParenBlock@{\futurelet\nextTok\scanParenBlockA@}
\def\scanParenBlockA@{%
    \ifx\bgroup\nextTok\let\next=\scanBraced@
    \else\let\next=\scanParenBlockB@
    \fi\next
}
\def\scanBraced@#1{%
    \appendToks@\parenContents@{{#1}}%
    \scanParenBlock@
}
\def\scanParenBlockB@#1{%
    \ifx#1\endParen
        \ifnum0<\parenLevel@
            \def\next{%
                \advance\parenLevel@ by -1%
                \appendToks@\parenContents@{\endParen}%
                \scanParenBlock@
            }%
        \else\def\next##1{%
                \edef\newStuff{%
                    1{\parenStarter##1}{\the\parenContents@}%
                }%
                \expandafter\useT\newStuff%
            }%
        \fi
    \else
        \ifx#1\startParen\advance\parenLevel@ by 1\fi
        \appendToks@\parenContents@{#1}%
        \let\next=\scanParenBlock@
    \fi
    \next
}


%%%%%%%%%%%%%
% Using TeX macros inside of ASCIIMath:
%
% A macro which takes no arguments (for example, \alpha or \Sum) can always
% be referred to by name.  And a build-in macro like \sqrt will work.  But
% other macros which take an argumetn will not work by default.
%
% The following macro tells the ASCIIMath engine that a macro takes arguments:
% It works by setting a corresponding macro name which the engine will look up.
% Outermost parentheses of arguments will be eliminated (just like for sqrt).
% The format is:
% <name> -> @name@asciimacro@
% The macro definition will internally keep track of the number of args.
%
% Usage example:
% 
% \newcommand{\myroot}[2]{\sqrt[#1]{#2}}
% \addASCIIMathCmd{root}{\myroot}{2}
%
\def\addASCIIMathCmd#1#2#3{%
    \begingroup
    \makeatletter
    \edef\name{@#1@asciimacro@}%
    \def\macroValue{{#3}#2}%
    \expandafter\global\expandafter\let\csname\name\endcsname=\macroValue
    \endgroup
}

% Start off with a couple of definitions:
% sqrt, root, hat, bb@
\addASCIIMathCmd{sqrt}{1}{\sqrt}
\def\myrootn@#1#2{{\sqrt[#1]{#2}}}
\addASCIIMathCmd{root}{2}{\myrootn@}
\addASCIIMathCmd{bb}{1}{\mathbb}
\addASCIIMathCmd{hat}{1}{\hat}
