% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
 

\newlinechar=`@

% OK, change: need  to fully lex into a token register before outputting.
\newtoks\tempStrA
\def\appendToks#1#2{%
    \tempStrA={#2}%
%    \message{Appending to \noexpand#1: [\the#1] plus [\the\tempStrA]@}
    \edef\tmpA{\the#1\the\tempStrA}%
    #1=\expandafter{\tmpA}%
}

\catcode96=13%
\def`{\setup\startParse}
\def\setup{%
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
    %\defParenCmds
}

\newtoks\lexedTokens
\def\addLexed{\appendToks\lexedTokens}
\def\addBlock#1{\addLexed{\block0{}{#1}}}

\def\startParse#1`{%
    %\message{Starting to lex:}
    \lexedTokens={}\lexTokens#1\end
    \message{The lexed tokens: \the\lexedTokens@}%
    %\message{done.}%
    \mathdelim\the\lexedTokens\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
% 
% TODO (maybe these shouldn't go here):
% * Register \sqrt (maybe that shouldn't go here?)
% * Try using operator precedence: a^2/b_3 == (a^2)/(b_3)
% * also a^2_1 should work better
%
\begingroup
\catcode32=13
%\catcode40=13
\gdef\sspaceB{ }
\gdef\sparenB{(}
\catcode32=10
\endgroup



% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\gdef\lexTokens#1{%
    \ifx#1\end\let\next=\relax
    %\message{About to test spaces...first is:}
    %\show#1%
    %\message{And second is:}
    %\show\sspaceB
    %\message{So there.}
    %\if\sspaceB\noexpand#1\message{YESYES}\else\message{NONO}\fi
    % the noexpand is necessary if eg we parse an active (.
    \else\if\sspaceB\noexpand#1\let\next=\lexTokens% ignore spaces
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS#1}%
    \else\ifcat\noexpand#1^\def\next{\addLexed{^}\lexTokens}%
    \else\ifcat\noexpand#1_\def\next{\addLexed{_}\lexTokens}%
    \else\ifcat\noexpand#1/\def\next{\processOtherChar#1}%
    \else\def\next{\addBlock{#1}\lexTokens}%
    \fi\fi\fi\fi\fi\fi
    \next
}%

\def\processOtherChar#1{%
    \ifx#1/\let\next=\scanFracOrDiv
    \else\ifx#1(\def\next{\addLexed{\startParen(}\lexTokens}%
    \else\ifx#1[\def\next{\addLexed{\startParen[}\lexTokens}%
    \else\ifx#1)\def\next{\addLexed{\endParen)}\lexTokens}%
    \else\ifx#1]\def\next{\addLexed{\endParen]}\lexTokens}%
    \else\ifx#1-\def\next{\scanMinusOrNeg}%
    % TODO: if it's a digit (or if it's a '-' and the next token's a digit
    % then read a number and turn it into a block.
    \else
        \ifisdigit#1{\def\next{\scanNumber{#1}}}%
            {\def\next{\addBlock{#1}\lexTokens}}%
    \fi\fi\fi\fi\fi\fi
    \next
}

\def\scanFracOrDiv{\futurelet\nextTok\scanFracOrDivA}
\def\scanFracOrDivA{%
    \ifx\nextTok/\def\next##1{\addBlock{/}\lexTokens}%
    \else\def\next{\addLexed{/}\lexTokens}%
    \fi
    \next
}

% There must be a more efficient way to do this...
\newif\ifisDigitCond
\def\ifisdigit#1#2#3{%
    \isDigitCondfalse
    \ifx0#1\isDigitCondtrue\fi
    \ifx1#1\isDigitCondtrue\fi
    \ifx2#1\isDigitCondtrue\fi
    \ifx3#1\isDigitCondtrue\fi
    \ifx4#1\isDigitCondtrue\fi
    \ifx5#1\isDigitCondtrue\fi
    \ifx6#1\isDigitCondtrue\fi
    \ifx7#1\isDigitCondtrue\fi
    \ifx8#1\isDigitCondtrue\fi
    \ifx9#1\isDigitCondtrue\fi
    \ifisDigitCond#2\else#3\fi
}

\def\scanNumber#1{\def\todo{\scanNumberA{#1}}\futurelet\nextTok\todo}
\def\scanNumberA#1{%
    \ifisdigit\nextTok{\def\next##1{\scanNumber{#1##1}}}%
        {\def\next{\addBlock{#1}\lexTokens}}%
    \next
}

% scanned a '-'; need to peek one more to check if this starts a negative number.
\def\scanMinusOrNeg{\futurelet\nextTok\scanMinusOrNegA}
\def\scanMinusOrNegA{%
    \ifisdigit\nextTok
        {\def\next{\scanNumber{-}}}%
        {\def\next{\addBlock{-}\lexTokens}}%
    \next
}

%%%%%%%%%%%
% binary operations
\def\fracOp#1#2{%
    {#1\over#2}%
}
\def\Superscript#1#2{%
    {#1}^{#2}%
}
\def\Subscript#1#2{%
    {#1}_{#2}%
}

\newtoks\csNameStr
\def\parseLetterOrCS#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\nextTok a\def\next{\csNameStr={#1}\parseCS}%
                \else\def\next{\addBlock#1\lexTokens}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS{\futurelet\nextTok\parseCSa}
\def\parseCSa{%
    \ifcat\nextTok a\def\next{\addToCSAndCont}%
    \else\def\next{\emitCSAndLex}%
    \fi\next
}
\def\addToCSAndCont#1{%
    \appendToks\csNameStr#1%\edef\next{\noexpand\csNameStr={\the\csNameStr#1}}%
    \parseCS
}
\def\emitCSAndLex{%
    %TODO: if seq is sqrt, then just add \blockSqrt (unwrapped) and continue \lexTokens.
    % otherwise, add it.
    \def\tempSqrt{sqrt}%
    \edef\scannedStr{\the\csNameStr}%
    \ifx\tempSqrt\scannedStr
        \def\next{\addLexed{\blockSqrt}\lexTokens}%
    \else
        \def\next{%
            \expandafter\expandafter\expandafter
                \addBlock\expandafter\csname\scannedStr\endcsname
            \lexTokens
        }%
    \fi\next
    %\edef\nextL{\csname\the\csNameStr\endcsname}%
    %\expandafter\addLexed\nextL\lexTokens
}

%%%%%%%%%%%%%%
%% Parsing lexed tokens into a large structure
%
% Grammar is:
% 
% E ->  O E  | <empty>
% O ->  S    | S / S
% S ->  T    | T^T  | T_T   | T_T^T
% T -> <block> or (E)
%
% We handle the recursion by just accumulating the unexpanded inside
% and later outputting it inside of parens, \frac, etc.
% In particular, readO is NOT a recursive macro.
%
% Objects inside are:
% simple binary operations /, ^ or _
% \block#1#2#3: #1 is 1 if this should be wrapped with parens when not a
%                   subexpr of a fraction, exponent, etc., and 0 otherwise.
%               #2 is eg "()" or "[)" if this should be wrapped
%               #3 is the internals of the block.
% \startParen#1: #1 is '(', '[', etc.
% \endParen#1: #1 is ')', ']', etc.
% 
% We also provide for other macros like \blockSqrt.  When it appears, it
% parses the upcoming block and expands into another block.

% When we get to an unprocessed block, we should start the parsing process over
% again.
\def\block{\readO\block}
\def\startParen{\readO\startParen}

\def\readO{\let\useS=\maybeDoFraction\readS}
\def\maybeDoFraction#1#2#3{%
    \ifNextTokIs/{\readFraction{#3}}{\putBlock#1{#2}{#3}}%
}

% Checks whether the next token is #1.  If so, eats it and runs #2.
% Otherwise, leaves it alone and runs #3.
\def\ifNextTokIs#1#2#3{%
    \def\todo{\ifx#1\nextTok\def\next####1{#2}\else\def\next{#3}\fi\next}%
    \futurelet\nextTok\todo
}
        
% Given the numerator to a fraction (#1)
% parses the next S and returns the resulting fraction.
\def\readFraction#1{%
    \def\useS##1##2##3{\fracOp{#1}{##3}}%
    \readS
}

% Reads an S nonterminal and passes the result to useS.
\def\readS{%
    \def\useT##1##2##3{%
        \ifNextTokIs_%
            {\doSubscript##1{##2}{##3}}%
            {\ifNextTokIs^%
                {\doSupscript##1{##2}{##3}}%
                {\useS##1{##2}{##3}}}%
    }
    \readT
}
% For now, no repeated yet.
\def\doSubscript#1#2#3{%
    \def\useT##1##2##3{%
        \ifNextTokIs^%
            {\doSubSupScript#1{#2}{#3}{##3}}%
            {\useS0{}{\putBlock#1{#2}{#3}_{##3}}}%
    }\readT
}
\def\doSupscript#1#2#3{%
    \def\useT##1##2##3{%
        \useS0{}{\putBlock#1{#2}{#3}^{##3}}%
    }\readT
}
\def\doSubSupScript#1#2#3#4{%
    \def\useT##1##2##3{%
        \useS0{}{\putBlock#1{#2}{#3}_{#4}^{##3}}%
    }\readT
}


\def\putBlock#1#2#3{%
    \ifx0#1\def\next{{#3}}%
    \else\def\next{{\wrapit#2{#3}}}%
    \fi\next
}
\def\wrapit#1#2#3{\left#1#3\right#2}

% \withReadT\nextT{...} : Reads a T, sets \nextT to a macro which expands to it,
% and runs {...}.
%\def\withReadT#1#2{\def\useT##1{\def#1{##1}\#2}\readT}
% Reads a "T" terminal (a lone block or a parenthesized expression)
% and then passes it as an argument to \useT.
\def\readT#1{%
    \ifx#1\block\let\next=\readTBlock
    \else\ifx#1\startParen\let\next=\readTParen
    \else\def\next{\message{Oops: ran into a non-block:\noexpand#1}\end}%
    \fi\fi
    % TODO: sqrt causes us to read another T.
    \next
}

\newtoks\parenContents
\newcount\parenLevel

\def\readTBlock#1#2#3{\useT#1{#2}{#3}}
\def\readTParen#1{%
    \def\parenStarter{#1}%
    \parenLevel=0\parenContents={}%
    \scanParenBlock
}
% Need to check whether a '{' is next (e.g. lexing numbers produces it)
\def\scanParenBlock{\futurelet\nextTok\scanParenBlockA}
\def\scanParenBlockA{%
    \ifx\bgroup\nextTok\let\next=\scanBraced
    \else\let\next=\scanParenBlockB
    \fi\next
}
\def\scanBraced#1{%
    \appendToks\parenContents{{#1}}
    \scanParenBlock
}
\def\scanParenBlockB#1{%
    \ifx#1\endParen
        \ifnum0<\parenLevel
            \def\next{
                \advance\parenLevel by -1%
                \appendToks\parenContents{\endParen}
                \scanParenBlock
            }%
        \else\def\next##1{%
                \edef\newStuff{%
                    1{\parenStarter##1}{\the\parenContents}%
                }%
                \expandafter\useT\newStuff%
            }%
        \fi
    \else
        \ifx#1\startParen\advance\parenLevel by 1\fi
        \appendToks\parenContents{#1}%
        \let\next=\scanParenBlock
    \fi
    \next
}



