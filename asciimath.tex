
\def\app#1#2\to#3{\let#1=#3 #2}

\def\usePeek#1#2{\def\todo{\app#1{#2}\to\nextToken}\futurelet\nextToken\todo}

%\def\ifLetterIsNext#1\else#2\fi{\usePeek\foo{%
%    \ifcat\foo a\def\next{#1}\else\def\next{#2}\fi\next}}

% eg \peekNext\temp{do some stuff}
\def\peekNext#1#2{\def\nextA{#2}\futurelet#1\nextA}
\def\ifLetterIsNext#1\else#2\fi{%
    \peekNext\nextLetter{\ifcat\nextLetter a\def\nextB{#1}\else\def\nextB{#2}\fi\nextB}}

%\def\ifLetterIsNext#1\else#2\fi{%
%    \def\todo{\ifcat\nextToken z\def\next{#1}\else\def\next{#2}\fi\next}%
%    \futurelet\nextToken\todo}

% Expands the upcoming sequence of letters.  (Assuming there's at least one.)
% If there's only one letter, we keep it as a letter.
% If there's more than one, we turn it into a token.
% Using this: (YES, more tex-y than my lambdas)
% \def\cont#1{#1\doMoreStuff}
% \expandafter\cont\mycsname
% But if it's only one letter, don't bother. (TODO)
\def\mycsname#1{%
    \ifLetterIsNext\mycsnameloop{#1}\else#1\fi
}
\def\mycsnameloop#1{
    \ifLetterIsNext\moreloop{#1}
    \else\csname#1\endcsname\fi
}
\def\moreloop#1#2{\mycsnameloop{#1#2}}

% when running csnamer, put the TODO macro in \csuser
\def\csnamer#1{%
    \ifLetterIsNext\csnamerloop{#1}\else\csuser#1\fi
}
\def\csnamerloop#1{
    \ifLetterIsNext\moreLooper{#1}
    \else\expandafter\csuser\csname#1\endcsname\fi
}
\def\moreLooper#1#2{\csnamerloop{#1#2}}

%%%%%%
% parentheses
% put the ``todo'' in \useParens
% Use as: \let\useParens=..\parseParens(...)
%
% First, no nesting.
% Then, count parens and only end when at zero level.
% (This is not efficient, but whatever.)
\newcount\parenNest
\def\parseParens#1{\parenNest=0\buildList}
\def\buildList#1#2{%
    \ifx#2)\ifnum\parenNest>0\def\next{\advance\parenNest-1\buildList{#1#2}}%
            \else\def\next{\useParens{#1}}\fi%
    \else\ifx#2(\advance\parenNest by 1\fi
        \def\next{\buildList{#1#2}}\fi
    \next
}

\def\parenWrap#1{\left(#1\right)}


%%%%%
% TODO: can't handle braces.
% TODO: parens, fractions, etc.
\catcode96=13%
\def`#1`{
\begingroup
\catcode32=\active
\ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
\def\useASCII##1{\mathdelim##1\mathdelim\endgroup}
\scanASCII{#1}
}
\def\scanASCII#1{\loopASCII{}#1\end}
\def\loopASCII#1{\def\next{\loopASCIIa{#1}}\futurelet\nextToken\next}
\def\loopASCIIa#1{%
    \ifx\nextToken\end\def\nextC{\useASCII{#1}}%
    \else\ifcat\nextToken a\def\nextC{%
        \def\csuser####1{\loopASCII{#1####1}}\csnamer}%
    \else\ifx\nextToken(\def\nextC{%
    % Fractions:
    % Once the paren is read, look ahead to the next character.
    % If it's a /, look ahead to the next symbol or parens
        \def\useParens####1{
            \bgroup\def\useASCII########1{
                \egroup\loopASCII{#1\parenWrap{########1}}}
            \scanASCII{####1}}%
        \parseParens}%
    \else\def\nextC##1{\loopASCII{#1##1}}%
    \fi\fi\fi\nextC
}

% A symbol is either a paren, a csname/letter, or an other char (eg 1)


% Read a paren'd list (counting nesting to make sure we're right),
% scan with scanASCII, then loop with that amount.

% TODOs
% 1) go back to more lambda-like: eg \withPeek\nextToken{...}
% 2) reorg w/scanning block by block, where each block is a:
     - paren 
     - single letter not followed by another letter
     - sequence of two or more letters forming a control seq
% 3) Use this to support /, ^, _
% 4) Allow nested braces for arguments to commands.

% TODO: square roots, braces

% Procedure:
% Keep running list of previously stored blocks.
% Drop spaces.  If we hit the end, stop.
% If we encounter an lbrace, then recurse on the contents of that block, then add the 
%   results to the list and repeat.
% Otherwise, read a block (A).
% Drop spaces.  
% If the next token (B) is /, ^ or _, then drop spaces and read another block (C).  Then, 
%    add {A}B{C} to the list.
% Otherwise, if A contains only one token, then add it to the list and repeat.
% Otherwise, add \left(A\right)}
% If the If the next token is NOT /, ^ or _, then 
%    if it's not a paren expr (ie contains only one token)
%        then just add (A) to the end of the list and repeat;
%    otherwise, add (A) with surrounding parens and repeat.
% 
% 

% Reading a block:
% first, drop any spaces.
% Look at the next token:
% If it's cat 12, that's it.
% If it's cat 11, if next token is not a letter then that's it.
%   otherwise, read as many letters as possible into one control sequence.
% If it's a it's followed by another letter the
% 

Stuff


Parser:
- read one block

Some stuff

%One \mycsname par abc

\tracingmacros=2
\tracingassigns=2

%\tracingcommands=2

% TODO: displaymath doesn't work!


\def\foo{2\over t}
`+(alpha*\Sigma (\foo2/gamma)beta)`
\tracingmacros=0
\tracingassigns=0

\bye
